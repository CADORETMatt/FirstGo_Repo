<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Canvas Interactif - Exemple Complet</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f0f0f0;
      overflow: hidden;
    }

    #canvasWrap {
      position: relative;
    }

    canvas {
      width: 600px;
      height: 600px;
      border: 1px solid #222;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      image-rendering: pixelated;
      touch-action: none;
      background: #fff;
      display: block;
    }

    .hud-btn {
      padding: 8px 10px;
      font-size: 13px;
      margin: 2px;
      border-radius: 6px;
      border: 1px solid rgba(0, 0, 0, 0.12);
      background: rgba(255, 255, 255, 0.9);
      cursor: pointer;
      z-index: 20;
    }

    #hudContainer {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 6px;
      z-index: 30;
    }

    #playerPos {
      font-family: monospace;
      font-size: 13px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(0, 0, 0, 0.12);
      border-radius: 6px;
      padding: 6px 8px;
    }
  </style>
</head>

<body>
  <div id="canvasWrap">
    <div id="hudContainer">
      <button class="hud-btn" id="zoomIn"> + </button>
      <button class="hud-btn" id="zoomOut"> - </button>
      <div id="playerPos">x: 0, y: 0</div>
    </div>
    <canvas id="gameCanvas" width="2500" height="2500" aria-label="Zone de jeu"></canvas>
  </div>

  <script src="TabTerrain.js"></script>

  <script>
    /* ---------------------------
       DeclaFunct.js (déclarations)
       --------------------------- */
    /* Ces fonctions ne s'exécutent pas tant qu'on ne les appelle pas depuis init(...) */
    function resizeCanvasToWindow(viewport, canvas) {
      const maxW = window.innerWidth, maxH = window.innerHeight;
      const ratio = viewport.width / viewport.height;
      let displayW = maxW, displayH = displayW / ratio;
      if (displayH > maxH) { displayH = maxH; displayW = displayH * ratio; }
      canvas.style.width = Math.round(displayW) + 'px';
      canvas.style.height = Math.round(displayH) + 'px';
    }

    function cssPointToWorld(clientX, clientY, viewport, canvas) {
      const rect = canvas.getBoundingClientRect();
      const nx = (clientX - rect.left) / rect.width;
      const ny = (clientY - rect.top) / rect.height;
      return { x: viewport.x + nx * viewport.width, y: viewport.y + ny * viewport.height };
    }

    function makeOnPointerDown(sol, viewport, canvas, setTargetFn) {
      // Factory qui retourne un handler sans capturer d'autres globals
      return function onPointerDown(e) {
        const p = e.touches ? e.touches[0] : e;
        const w = cssPointToWorld(p.clientX, p.clientY, viewport, canvas);
        if (w.x >= sol.x && w.x <= sol.x + sol.size && w.y >= sol.y && w.y <= sol.y + sol.size) {
          setTargetFn({ x: w.x, y: w.y });
        }
      };
    }

    function handleKeyboardMovement(point, keys, speed, sol) {
      let dx = 0, dy = 0;
      if (keys['z']) dy -= speed;
      if (keys['s']) dy += speed;
      if (keys['q']) dx -= speed;
      if (keys['d']) dx += speed;
      if (dx !== 0 || dy !== 0) {
        const nx = point.x + dx, ny = point.y + dy;
        if (nx >= sol.x && nx <= sol.x + sol.size && ny >= sol.y && ny <= sol.y + sol.size) {
          point.x = nx; point.y = ny;
        }
      }
    }

    function clampViewport(viewport, point, WORLD_SIZE) {
      // center then clamp
      viewport.x = point.x - viewport.width / 2;
      viewport.y = point.y - viewport.height / 2;
      if (viewport.x < 0) viewport.x = 0;
      if (viewport.y < 0) viewport.y = 0;
      if (viewport.x + viewport.width > WORLD_SIZE.w) viewport.x = WORLD_SIZE.w - viewport.width;
      if (viewport.y + viewport.height > WORLD_SIZE.h) viewport.y = WORLD_SIZE.h - viewport.height;
    }

    function updateHUD(posHUD, point) {
      posHUD.textContent = `x: ${point.x.toFixed(1)}, y: ${point.y.toFixed(1)}`;
    }

    function zoomViewport(factor, viewport, MIN_VIEW, MAX_VIEW) {
      const newW = Math.max(MIN_VIEW, Math.min(MAX_VIEW, viewport.width / factor));
      const newH = Math.max(MIN_VIEW, Math.min(MAX_VIEW, viewport.height / factor));
      const cx = viewport.x + viewport.width / 2;
      const cy = viewport.y + viewport.height / 2;
      viewport.width = newW; viewport.height = newH;
      viewport.x = cx - viewport.width / 2; viewport.y = cy - viewport.height / 2;
    }

    /* Prevent double tap helper (returns a function to attach) */
    function attachPreventDoubleTap(canvas) {
      let lastTouch = 0;
      const handler = e => {
        const t = Date.now();
        if (t - lastTouch < 300) e.preventDefault();
        lastTouch = t;
      };
      canvas.addEventListener('touchend', handler, { passive: false });
      return () => canvas.removeEventListener('touchend', handler); // cleanup if needed
    }

    /* ---------------------------
       Code principal (initialisation)
       --------------------------- */
    (function main() {
      // constantes / état
      const WORLD_SIZE = { w: 2500, h: 2500 };
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const posHUD = document.getElementById('playerPos');

      let point = { x: 1250, y: 1250, size: 10 };
      let target = null;
      const speed = 5;

      const sol = { x: 1000, y: 1000, size: 500, color: '#006400' };
      let viewport = { width: 600, height: 600, x: point.x - 600 / 2, y: point.y - 600 / 2 };

      const ZOOM_FACTOR = 1.2;
      const MIN_VIEW = 100;
      const MAX_VIEW = WORLD_SIZE.w;

      const keys = {};

      // terrain initialisé depuis TabTerrain.js
      let { terrainGrid, CELL_SIZE } = createNewTerrain('master');
      // (Test console)
      console.log('terrainGrid[25][25].nomBat =>', terrainGrid && terrainGrid[25] && terrainGrid[25][25] && terrainGrid[25][25].nomBat);
      console.log('CELL_SIZE =>', CELL_SIZE);

      // Fonctions draw et updateTarget (utilisent l'état local)
      function updateTargetLocal() {
        if (!target) return;
        const dx = target.x - point.x, dy = target.y - point.y;
        const dist = Math.hypot(dx, dy);
        if (dist < speed) { point.x = target.x; point.y = target.y; target = null; return; }
        const nx = point.x + (dx / dist) * speed;
        const ny = point.y + (dy / dist) * speed;
        if (nx < sol.x || nx > sol.x + sol.size || ny < sol.y || ny > sol.y + sol.size) { target = null; return; }
        point.x = nx; point.y = ny;
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const sx = canvas.width / viewport.width;
        const sy = canvas.height / viewport.height;
        ctx.save();
        ctx.scale(sx, sy);
        ctx.translate(-viewport.x, -viewport.y);

        ctx.fillStyle = sol.color;
        ctx.fillRect(sol.x, sol.y, sol.size, sol.size);

        ctx.fillStyle = 'red';
        const s = point.size;
        ctx.fillRect(point.x - s / 2, point.y - s / 2, s, s);

        if (target) {
          ctx.strokeStyle = 'blue';
          ctx.lineWidth = 2;
          ctx.strokeRect(target.x - 5, target.y - 5, 10, 10);
        }
        ctx.restore();
      }

      // Hook up events AFTER everything exists
      window.addEventListener('resize', () => resizeCanvasToWindow(viewport, canvas));
      resizeCanvasToWindow(viewport, canvas);

      document.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; e.preventDefault(); });
      document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

      // pointer handling: create handler with closure that sets `target`
      const onPointerDown = makeOnPointerDown(sol, viewport, canvas, t => target = t);
      canvas.addEventListener('mousedown', onPointerDown);
      canvas.addEventListener('touchstart', onPointerDown, { passive: true });

      // zoom buttons
      document.getElementById('zoomIn').addEventListener('click', () => { zoomViewport(ZOOM_FACTOR, viewport, MIN_VIEW, MAX_VIEW); resizeCanvasToWindow(viewport, canvas); });
      document.getElementById('zoomOut').addEventListener('click', () => { zoomViewport(1 / ZOOM_FACTOR, viewport, MIN_VIEW, MAX_VIEW); resizeCanvasToWindow(viewport, canvas); });

      // prevent double tap
      attachPreventDoubleTap(canvas);

      // game loop
      function gameLoop() {
        handleKeyboardMovement(point, keys, speed, sol);
        updateTargetLocal();
        clampViewport(viewport, point, WORLD_SIZE);
        draw();
        updateHUD(posHUD, point);
        requestAnimationFrame(gameLoop);
      }
      requestAnimationFrame(gameLoop);

    })(); // fin main IIFE

  </script>
</body>

</html>